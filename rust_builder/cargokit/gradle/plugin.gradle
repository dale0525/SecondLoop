/// This is copied from Cargokit (which is the official way to use it currently)
/// Details: https://fzyzcjy.github.io/flutter_rust_bridge/manual/integrate/builtin

import java.nio.file.Paths
import org.apache.tools.ant.taskdefs.condition.Os

CargoKitPlugin.file = buildscript.sourceFile

apply plugin: CargoKitPlugin

class CargoKitExtension {
    String manifestDir; // Relative path to folder containing Cargo.toml
    String libname; // Library name within Cargo.toml. Must be a cdylib
}

abstract class CargoKitBuildTask extends DefaultTask {

    @Input
    String buildMode

    @Input
    String buildDir

    @Input
    String outputDir

    @Input
    String ndkVersion

    @Input
    String sdkDirectory

    @Input
    int compileSdkVersion;

    @Input
    int minSdkVersion;

    @Input
    String pluginFile

    @Input
    List<String> targetPlatforms

    @TaskAction
    def build() {
        if (project.cargokit.manifestDir == null) {
            throw new GradleException("Property 'manifestDir' must be set on cargokit extension");
        }

        if (project.cargokit.libname == null) {
            throw new GradleException("Property 'libname' must be set on cargokit extension");
        }

        def executableName = Os.isFamily(Os.FAMILY_WINDOWS) ? "run_build_tool.cmd" : "run_build_tool.sh"
        def path = Paths.get(new File(pluginFile).parent, "..", executableName);

        def manifestDir = Paths.get(project.buildscript.sourceFile.parent, project.cargokit.manifestDir)

        def rootProjectDir = project.rootProject.projectDir

        // Prefer a project-local Rust toolchain if configured.
        def cargoHome = System.getenv("CARGO_HOME")
        if (cargoHome == null || cargoHome.trim().isEmpty()) {
            cargoHome = new File(rootProjectDir, ".tool/cargo").absolutePath
        }
        def rustupHome = System.getenv("RUSTUP_HOME")
        if (rustupHome == null || rustupHome.trim().isEmpty()) {
            rustupHome = new File(rootProjectDir, ".tool/rustup").absolutePath
        }
        def pathSeparator = Os.isFamily(Os.FAMILY_WINDOWS) ? ";" : ":"
        def cargoBinDir = new File(cargoHome, "bin").absolutePath
        def execPath = "${cargoBinDir}${pathSeparator}${System.getenv("PATH") ?: ""}"

        // Ensure Dart SDK >=3 by pointing build tool at Flutter's bundled Dart.
        // Flutter sets `flutter.sdk` in `android/local.properties` which we can reuse here.
        def flutterRoot = System.getenv("FLUTTER_ROOT")
        if ((flutterRoot == null || flutterRoot.trim().isEmpty()) && project.rootProject.file("local.properties").exists()) {
            def properties = new Properties()
            project.rootProject.file("local.properties").withInputStream { properties.load(it) }
            flutterRoot = properties.getProperty("flutter.sdk")
        }

        if (!Os.isFamily(Os.FAMILY_WINDOWS)) {
            project.exec {
                commandLine 'chmod', '+x', path
            }
        }

        project.exec {
            executable path
            args "build-gradle"
            environment "CARGOKIT_ROOT_PROJECT_DIR", rootProjectDir
            environment "CARGOKIT_TOOL_TEMP_DIR", "${buildDir}/build_tool"
            environment "CARGOKIT_MANIFEST_DIR", manifestDir
            environment "CARGOKIT_CONFIGURATION", buildMode
            environment "CARGOKIT_TARGET_TEMP_DIR", buildDir
            environment "CARGOKIT_OUTPUT_DIR", outputDir
            environment "CARGOKIT_NDK_VERSION", ndkVersion
            environment "CARGOKIT_SDK_DIR", sdkDirectory
            environment "CARGOKIT_COMPILE_SDK_VERSION", compileSdkVersion
            environment "CARGOKIT_MIN_SDK_VERSION", minSdkVersion
            environment "CARGOKIT_TARGET_PLATFORMS", targetPlatforms.join(",")
            environment "CARGOKIT_JAVA_HOME", System.properties['java.home']
            environment "CARGO_HOME", cargoHome
            environment "RUSTUP_HOME", rustupHome
            environment "PATH", execPath
            if (flutterRoot != null && !flutterRoot.trim().isEmpty()) {
                environment "FLUTTER_ROOT", flutterRoot
            }
        }
    }
}

class CargoKitPlugin implements Plugin<Project> {

    static String file;

    private Project findFlutterProject(Project rootProject) {
        rootProject.allprojects.find { candidate ->
            candidate.plugins.hasPlugin("dev.flutter.flutter-gradle-plugin") ||
                candidate.plugins.any { plugin ->
                    // Flutter changed the implementation class name in recent versions.
                    plugin.class.name == "FlutterPlugin" ||
                        plugin.class.name == "com.flutter.gradle.FlutterPlugin"
                }
        }
    }

    private static List<String> resolveTargetPlatforms(Project project) {
        if (!project.hasProperty("target-platform")) {
            return ["android-arm", "android-arm64", "android-x64"]
        }
        return project
            .property("target-platform")
            .toString()
            .split(",")
            .collect { it.trim() }
            .findAll { !it.isEmpty() }
    }

    private static int resolveCompileSdkVersion(Project androidProject) {
        def value = null
        if (androidProject.android.hasProperty("compileSdkVersion")) {
            value = androidProject.android.compileSdkVersion
        } else if (androidProject.android.hasProperty("compileSdk")) {
            value = androidProject.android.compileSdk
        }
        if (value == null) {
            throw new GradleException("Could not determine compileSdkVersion")
        }
        if (value instanceof Integer) {
            return value as int
        }
        def text = value.toString()
        if (text.startsWith("android-")) {
            text = text.substring("android-".length())
        }
        return Integer.parseInt(text)
    }

    @Override
    void apply(Project project) {
        project.extensions.create("cargokit", CargoKitExtension)

        project.gradle.projectsEvaluated {
            def flutterProject = findFlutterProject(project.rootProject)
            if (flutterProject == null) {
                print("Flutter plugin not found, CargoKit plugin will not be applied.")
                return
            }

            def cargoBuildDir = "${project.buildDir}/build"

            def variants = project.plugins.hasPlugin('com.android.application') ?
                project.android.applicationVariants :
                project.android.libraryVariants

            variants.all { variant ->
                final buildType = variant.buildType.name

                def cargoOutputDir = "${project.buildDir}/jniLibs/${buildType}"
                def jniLibs = project.android.sourceSets.maybeCreate(buildType).jniLibs
                jniLibs.srcDir(new File(cargoOutputDir))

                def platforms = resolveTargetPlatforms(project)
                if (buildType == "debug") {
                    platforms.add("android-x86")
                    platforms.add("android-x64")
                }
                platforms = platforms.unique()

                def taskName = "cargokitCargoBuild${project.cargokit.libname.capitalize()}${buildType.capitalize()}"

                if (project.tasks.findByName(taskName)) {
                    return
                }

                if (flutterProject.android.ndkVersion == null) {
                    throw new GradleException("Please set 'android.ndkVersion' in 'app/build.gradle'.")
                }

                def task = project.tasks.create(taskName, CargoKitBuildTask.class) {
                    buildMode = buildType
                    buildDir = cargoBuildDir
                    outputDir = cargoOutputDir
                    ndkVersion = flutterProject.android.ndkVersion
                    sdkDirectory = flutterProject.android.sdkDirectory
                    minSdkVersion = flutterProject.android.defaultConfig.minSdkVersion.apiLevel as int
                    compileSdkVersion = resolveCompileSdkVersion(flutterProject)
                    targetPlatforms = platforms
                    pluginFile = CargoKitPlugin.file
                }

                def onTask = { newTask ->
                    if (newTask.name == "merge${buildType.capitalize()}NativeLibs") {
                        newTask.dependsOn task
                        // Fix gradle not picking up JNI library changes
                        newTask.outputs.upToDateWhen { false }
                    }
                }
                project.tasks.each onTask
                project.tasks.whenTaskAdded onTask
            }
        }
    }
}
