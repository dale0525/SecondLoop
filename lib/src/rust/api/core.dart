// This file is automatically generated, so please do not edit it.
// Generated by `flutter_rust_bridge`@ 2.0.0-dev.38.

// ignore_for_file: invalid_use_of_internal_member, unused_import, unnecessary_import

import '../db.dart';
import '../frb_generated.dart';
import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated.dart';

// These functions are ignored because they are not marked as `pub`: `default_embedding_model_name_for_platform`, `key_from_bytes`, `normalize_embedding_model_name`, `sync_key_from_bytes`

Future<bool> authIsInitialized({required String appDir}) =>
    RustLib.instance.api.crateApiCoreAuthIsInitialized(appDir: appDir);

Future<Uint8List> authInitMasterPassword(
        {required String appDir, required String password}) =>
    RustLib.instance.api
        .crateApiCoreAuthInitMasterPassword(appDir: appDir, password: password);

Future<Uint8List> authUnlockWithPassword(
        {required String appDir, required String password}) =>
    RustLib.instance.api
        .crateApiCoreAuthUnlockWithPassword(appDir: appDir, password: password);

Future<void> authValidateKey(
        {required String appDir, required List<int> key}) =>
    RustLib.instance.api.crateApiCoreAuthValidateKey(appDir: appDir, key: key);

Future<List<Conversation>> dbListConversations(
        {required String appDir, required List<int> key}) =>
    RustLib.instance.api
        .crateApiCoreDbListConversations(appDir: appDir, key: key);

Future<Conversation> dbCreateConversation(
        {required String appDir,
        required List<int> key,
        required String title}) =>
    RustLib.instance.api.crateApiCoreDbCreateConversation(
        appDir: appDir, key: key, title: title);

Future<Conversation> dbGetOrCreateMainStreamConversation(
        {required String appDir, required List<int> key}) =>
    RustLib.instance.api.crateApiCoreDbGetOrCreateMainStreamConversation(
        appDir: appDir, key: key);

Future<List<Message>> dbListMessages(
        {required String appDir,
        required List<int> key,
        required String conversationId}) =>
    RustLib.instance.api.crateApiCoreDbListMessages(
        appDir: appDir, key: key, conversationId: conversationId);

Future<Message> dbInsertMessage(
        {required String appDir,
        required List<int> key,
        required String conversationId,
        required String role,
        required String content}) =>
    RustLib.instance.api.crateApiCoreDbInsertMessage(
        appDir: appDir,
        key: key,
        conversationId: conversationId,
        role: role,
        content: content);

Future<void> dbEditMessage(
        {required String appDir,
        required List<int> key,
        required String messageId,
        required String content}) =>
    RustLib.instance.api.crateApiCoreDbEditMessage(
        appDir: appDir, key: key, messageId: messageId, content: content);

Future<void> dbSetMessageDeleted(
        {required String appDir,
        required List<int> key,
        required String messageId,
        required bool isDeleted}) =>
    RustLib.instance.api.crateApiCoreDbSetMessageDeleted(
        appDir: appDir, key: key, messageId: messageId, isDeleted: isDeleted);

Future<void> dbResetVaultDataPreservingLlmProfiles(
        {required String appDir, required List<int> key}) =>
    RustLib.instance.api.crateApiCoreDbResetVaultDataPreservingLlmProfiles(
        appDir: appDir, key: key);

Future<LlmProfile> dbCreateLlmProfile(
        {required String appDir,
        required List<int> key,
        required String name,
        required String providerType,
        String? baseUrl,
        String? apiKey,
        required String modelName,
        required bool setActive}) =>
    RustLib.instance.api.crateApiCoreDbCreateLlmProfile(
        appDir: appDir,
        key: key,
        name: name,
        providerType: providerType,
        baseUrl: baseUrl,
        apiKey: apiKey,
        modelName: modelName,
        setActive: setActive);

Future<List<LlmProfile>> dbListLlmProfiles(
        {required String appDir, required List<int> key}) =>
    RustLib.instance.api
        .crateApiCoreDbListLlmProfiles(appDir: appDir, key: key);

Future<void> dbSetActiveLlmProfile(
        {required String appDir,
        required List<int> key,
        required String profileId}) =>
    RustLib.instance.api.crateApiCoreDbSetActiveLlmProfile(
        appDir: appDir, key: key, profileId: profileId);

Future<void> dbDeleteLlmProfile(
        {required String appDir,
        required List<int> key,
        required String profileId}) =>
    RustLib.instance.api.crateApiCoreDbDeleteLlmProfile(
        appDir: appDir, key: key, profileId: profileId);

Future<int> dbProcessPendingMessageEmbeddings(
        {required String appDir, required List<int> key, required int limit}) =>
    RustLib.instance.api.crateApiCoreDbProcessPendingMessageEmbeddings(
        appDir: appDir, key: key, limit: limit);

Future<List<SimilarMessage>> dbSearchSimilarMessages(
        {required String appDir,
        required List<int> key,
        required String query,
        required int topK}) =>
    RustLib.instance.api.crateApiCoreDbSearchSimilarMessages(
        appDir: appDir, key: key, query: query, topK: topK);

Future<int> dbRebuildMessageEmbeddings(
        {required String appDir,
        required List<int> key,
        required int batchLimit}) =>
    RustLib.instance.api.crateApiCoreDbRebuildMessageEmbeddings(
        appDir: appDir, key: key, batchLimit: batchLimit);

Future<List<String>> dbListEmbeddingModelNames(
        {required String appDir, required List<int> key}) =>
    RustLib.instance.api
        .crateApiCoreDbListEmbeddingModelNames(appDir: appDir, key: key);

Future<String> dbGetActiveEmbeddingModelName(
        {required String appDir, required List<int> key}) =>
    RustLib.instance.api
        .crateApiCoreDbGetActiveEmbeddingModelName(appDir: appDir, key: key);

Future<bool> dbSetActiveEmbeddingModelName(
        {required String appDir,
        required List<int> key,
        required String modelName}) =>
    RustLib.instance.api.crateApiCoreDbSetActiveEmbeddingModelName(
        appDir: appDir, key: key, modelName: modelName);

Stream<String> ragAskAiStream(
        {required String appDir,
        required List<int> key,
        required String conversationId,
        required String question,
        required int topK,
        required bool thisThreadOnly}) =>
    RustLib.instance.api.crateApiCoreRagAskAiStream(
        appDir: appDir,
        key: key,
        conversationId: conversationId,
        question: question,
        topK: topK,
        thisThreadOnly: thisThreadOnly);

Future<Uint8List> syncDeriveKey({required String passphrase}) =>
    RustLib.instance.api.crateApiCoreSyncDeriveKey(passphrase: passphrase);

Future<void> syncWebdavTestConnection(
        {required String baseUrl,
        String? username,
        String? password,
        required String remoteRoot}) =>
    RustLib.instance.api.crateApiCoreSyncWebdavTestConnection(
        baseUrl: baseUrl,
        username: username,
        password: password,
        remoteRoot: remoteRoot);

Future<BigInt> syncWebdavPush(
        {required String appDir,
        required List<int> key,
        required List<int> syncKey,
        required String baseUrl,
        String? username,
        String? password,
        required String remoteRoot}) =>
    RustLib.instance.api.crateApiCoreSyncWebdavPush(
        appDir: appDir,
        key: key,
        syncKey: syncKey,
        baseUrl: baseUrl,
        username: username,
        password: password,
        remoteRoot: remoteRoot);

Future<BigInt> syncWebdavPull(
        {required String appDir,
        required List<int> key,
        required List<int> syncKey,
        required String baseUrl,
        String? username,
        String? password,
        required String remoteRoot}) =>
    RustLib.instance.api.crateApiCoreSyncWebdavPull(
        appDir: appDir,
        key: key,
        syncKey: syncKey,
        baseUrl: baseUrl,
        username: username,
        password: password,
        remoteRoot: remoteRoot);

Future<void> syncWebdavClearRemoteRoot(
        {required String baseUrl,
        String? username,
        String? password,
        required String remoteRoot}) =>
    RustLib.instance.api.crateApiCoreSyncWebdavClearRemoteRoot(
        baseUrl: baseUrl,
        username: username,
        password: password,
        remoteRoot: remoteRoot);

Future<void> syncLocaldirTestConnection(
        {required String localDir, required String remoteRoot}) =>
    RustLib.instance.api.crateApiCoreSyncLocaldirTestConnection(
        localDir: localDir, remoteRoot: remoteRoot);

Future<BigInt> syncLocaldirPush(
        {required String appDir,
        required List<int> key,
        required List<int> syncKey,
        required String localDir,
        required String remoteRoot}) =>
    RustLib.instance.api.crateApiCoreSyncLocaldirPush(
        appDir: appDir,
        key: key,
        syncKey: syncKey,
        localDir: localDir,
        remoteRoot: remoteRoot);

Future<BigInt> syncLocaldirPull(
        {required String appDir,
        required List<int> key,
        required List<int> syncKey,
        required String localDir,
        required String remoteRoot}) =>
    RustLib.instance.api.crateApiCoreSyncLocaldirPull(
        appDir: appDir,
        key: key,
        syncKey: syncKey,
        localDir: localDir,
        remoteRoot: remoteRoot);

Future<void> syncLocaldirClearRemoteRoot(
        {required String localDir, required String remoteRoot}) =>
    RustLib.instance.api.crateApiCoreSyncLocaldirClearRemoteRoot(
        localDir: localDir, remoteRoot: remoteRoot);
