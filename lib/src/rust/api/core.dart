// This file is automatically generated, so please do not edit it.
// Generated by `flutter_rust_bridge`@ 2.0.0-dev.38.

// ignore_for_file: invalid_use_of_internal_member, unused_import, unnecessary_import

import '../db.dart';
import '../frb_generated.dart';
import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated.dart';

// These functions are ignored because they are not marked as `pub`: `default_embedding_model_name_for_platform`, `key_from_bytes`, `normalize_embedding_model_name`, `sync_key_from_bytes`

Future<bool> authIsInitialized({required String appDir}) =>
    RustLib.instance.api.crateApiCoreAuthIsInitialized(appDir: appDir);

Future<Uint8List> authInitMasterPassword(
        {required String appDir, required String password}) =>
    RustLib.instance.api
        .crateApiCoreAuthInitMasterPassword(appDir: appDir, password: password);

Future<Uint8List> authUnlockWithPassword(
        {required String appDir, required String password}) =>
    RustLib.instance.api
        .crateApiCoreAuthUnlockWithPassword(appDir: appDir, password: password);

Future<void> authValidateKey(
        {required String appDir, required List<int> key}) =>
    RustLib.instance.api.crateApiCoreAuthValidateKey(appDir: appDir, key: key);

Future<List<Conversation>> dbListConversations(
        {required String appDir, required List<int> key}) =>
    RustLib.instance.api
        .crateApiCoreDbListConversations(appDir: appDir, key: key);

Future<Conversation> dbCreateConversation(
        {required String appDir,
        required List<int> key,
        required String title}) =>
    RustLib.instance.api.crateApiCoreDbCreateConversation(
        appDir: appDir, key: key, title: title);

Future<Conversation> dbGetOrCreateMainStreamConversation(
        {required String appDir, required List<int> key}) =>
    RustLib.instance.api.crateApiCoreDbGetOrCreateMainStreamConversation(
        appDir: appDir, key: key);

Future<List<Message>> dbListMessages(
        {required String appDir,
        required List<int> key,
        required String conversationId}) =>
    RustLib.instance.api.crateApiCoreDbListMessages(
        appDir: appDir, key: key, conversationId: conversationId);

Future<Message> dbInsertMessage(
        {required String appDir,
        required List<int> key,
        required String conversationId,
        required String role,
        required String content}) =>
    RustLib.instance.api.crateApiCoreDbInsertMessage(
        appDir: appDir,
        key: key,
        conversationId: conversationId,
        role: role,
        content: content);

Future<Todo> dbUpsertTodo(
        {required String appDir,
        required List<int> key,
        required String id,
        required String title,
        PlatformInt64? dueAtMs,
        required String status,
        String? sourceEntryId,
        PlatformInt64? reviewStage,
        PlatformInt64? nextReviewAtMs,
        PlatformInt64? lastReviewAtMs}) =>
    RustLib.instance.api.crateApiCoreDbUpsertTodo(
        appDir: appDir,
        key: key,
        id: id,
        title: title,
        dueAtMs: dueAtMs,
        status: status,
        sourceEntryId: sourceEntryId,
        reviewStage: reviewStage,
        nextReviewAtMs: nextReviewAtMs,
        lastReviewAtMs: lastReviewAtMs);

Future<List<Todo>> dbListTodos(
        {required String appDir, required List<int> key}) =>
    RustLib.instance.api.crateApiCoreDbListTodos(appDir: appDir, key: key);

Future<Todo> dbSetTodoStatus(
        {required String appDir,
        required List<int> key,
        required String todoId,
        required String newStatus,
        String? sourceMessageId}) =>
    RustLib.instance.api.crateApiCoreDbSetTodoStatus(
        appDir: appDir,
        key: key,
        todoId: todoId,
        newStatus: newStatus,
        sourceMessageId: sourceMessageId);

Future<TodoActivity> dbAppendTodoNote(
        {required String appDir,
        required List<int> key,
        required String todoId,
        required String content,
        String? sourceMessageId}) =>
    RustLib.instance.api.crateApiCoreDbAppendTodoNote(
        appDir: appDir,
        key: key,
        todoId: todoId,
        content: content,
        sourceMessageId: sourceMessageId);

Future<List<TodoActivity>> dbListTodoActivities(
        {required String appDir,
        required List<int> key,
        required String todoId}) =>
    RustLib.instance.api.crateApiCoreDbListTodoActivities(
        appDir: appDir, key: key, todoId: todoId);

Future<Event> dbUpsertEvent(
        {required String appDir,
        required List<int> key,
        required String id,
        required String title,
        required PlatformInt64 startAtMs,
        required PlatformInt64 endAtMs,
        required String tz,
        String? sourceEntryId}) =>
    RustLib.instance.api.crateApiCoreDbUpsertEvent(
        appDir: appDir,
        key: key,
        id: id,
        title: title,
        startAtMs: startAtMs,
        endAtMs: endAtMs,
        tz: tz,
        sourceEntryId: sourceEntryId);

Future<List<Event>> dbListEvents(
        {required String appDir, required List<int> key}) =>
    RustLib.instance.api.crateApiCoreDbListEvents(appDir: appDir, key: key);

Future<void> dbEditMessage(
        {required String appDir,
        required List<int> key,
        required String messageId,
        required String content}) =>
    RustLib.instance.api.crateApiCoreDbEditMessage(
        appDir: appDir, key: key, messageId: messageId, content: content);

Future<void> dbSetMessageDeleted(
        {required String appDir,
        required List<int> key,
        required String messageId,
        required bool isDeleted}) =>
    RustLib.instance.api.crateApiCoreDbSetMessageDeleted(
        appDir: appDir, key: key, messageId: messageId, isDeleted: isDeleted);

Future<Attachment> dbInsertAttachment(
        {required String appDir,
        required List<int> key,
        required List<int> bytes,
        required String mimeType}) =>
    RustLib.instance.api.crateApiCoreDbInsertAttachment(
        appDir: appDir, key: key, bytes: bytes, mimeType: mimeType);

Future<void> dbLinkAttachmentToMessage(
        {required String appDir,
        required List<int> key,
        required String messageId,
        required String attachmentSha256}) =>
    RustLib.instance.api.crateApiCoreDbLinkAttachmentToMessage(
        appDir: appDir,
        key: key,
        messageId: messageId,
        attachmentSha256: attachmentSha256);

Future<List<Attachment>> dbListMessageAttachments(
        {required String appDir,
        required List<int> key,
        required String messageId}) =>
    RustLib.instance.api.crateApiCoreDbListMessageAttachments(
        appDir: appDir, key: key, messageId: messageId);

Future<Uint8List> dbReadAttachmentBytes(
        {required String appDir,
        required List<int> key,
        required String sha256}) =>
    RustLib.instance.api.crateApiCoreDbReadAttachmentBytes(
        appDir: appDir, key: key, sha256: sha256);

Future<void> dbResetVaultDataPreservingLlmProfiles(
        {required String appDir, required List<int> key}) =>
    RustLib.instance.api.crateApiCoreDbResetVaultDataPreservingLlmProfiles(
        appDir: appDir, key: key);

Future<LlmProfile> dbCreateLlmProfile(
        {required String appDir,
        required List<int> key,
        required String name,
        required String providerType,
        String? baseUrl,
        String? apiKey,
        required String modelName,
        required bool setActive}) =>
    RustLib.instance.api.crateApiCoreDbCreateLlmProfile(
        appDir: appDir,
        key: key,
        name: name,
        providerType: providerType,
        baseUrl: baseUrl,
        apiKey: apiKey,
        modelName: modelName,
        setActive: setActive);

Future<List<LlmProfile>> dbListLlmProfiles(
        {required String appDir, required List<int> key}) =>
    RustLib.instance.api
        .crateApiCoreDbListLlmProfiles(appDir: appDir, key: key);

Future<void> dbSetActiveLlmProfile(
        {required String appDir,
        required List<int> key,
        required String profileId}) =>
    RustLib.instance.api.crateApiCoreDbSetActiveLlmProfile(
        appDir: appDir, key: key, profileId: profileId);

Future<void> dbDeleteLlmProfile(
        {required String appDir,
        required List<int> key,
        required String profileId}) =>
    RustLib.instance.api.crateApiCoreDbDeleteLlmProfile(
        appDir: appDir, key: key, profileId: profileId);

Future<int> dbProcessPendingMessageEmbeddings(
        {required String appDir, required List<int> key, required int limit}) =>
    RustLib.instance.api.crateApiCoreDbProcessPendingMessageEmbeddings(
        appDir: appDir, key: key, limit: limit);

Future<List<SimilarMessage>> dbSearchSimilarMessages(
        {required String appDir,
        required List<int> key,
        required String query,
        required int topK}) =>
    RustLib.instance.api.crateApiCoreDbSearchSimilarMessages(
        appDir: appDir, key: key, query: query, topK: topK);

Future<int> dbRebuildMessageEmbeddings(
        {required String appDir,
        required List<int> key,
        required int batchLimit}) =>
    RustLib.instance.api.crateApiCoreDbRebuildMessageEmbeddings(
        appDir: appDir, key: key, batchLimit: batchLimit);

Future<List<String>> dbListEmbeddingModelNames(
        {required String appDir, required List<int> key}) =>
    RustLib.instance.api
        .crateApiCoreDbListEmbeddingModelNames(appDir: appDir, key: key);

Future<String> dbGetActiveEmbeddingModelName(
        {required String appDir, required List<int> key}) =>
    RustLib.instance.api
        .crateApiCoreDbGetActiveEmbeddingModelName(appDir: appDir, key: key);

Future<bool> dbSetActiveEmbeddingModelName(
        {required String appDir,
        required List<int> key,
        required String modelName}) =>
    RustLib.instance.api.crateApiCoreDbSetActiveEmbeddingModelName(
        appDir: appDir, key: key, modelName: modelName);

Stream<String> ragAskAiStream(
        {required String appDir,
        required List<int> key,
        required String conversationId,
        required String question,
        required int topK,
        required bool thisThreadOnly}) =>
    RustLib.instance.api.crateApiCoreRagAskAiStream(
        appDir: appDir,
        key: key,
        conversationId: conversationId,
        question: question,
        topK: topK,
        thisThreadOnly: thisThreadOnly);

Stream<String> ragAskAiStreamCloudGateway(
        {required String appDir,
        required List<int> key,
        required String conversationId,
        required String question,
        required int topK,
        required bool thisThreadOnly,
        required String gatewayBaseUrl,
        required String firebaseIdToken,
        required String modelName}) =>
    RustLib.instance.api.crateApiCoreRagAskAiStreamCloudGateway(
        appDir: appDir,
        key: key,
        conversationId: conversationId,
        question: question,
        topK: topK,
        thisThreadOnly: thisThreadOnly,
        gatewayBaseUrl: gatewayBaseUrl,
        firebaseIdToken: firebaseIdToken,
        modelName: modelName);

Future<Uint8List> syncDeriveKey({required String passphrase}) =>
    RustLib.instance.api.crateApiCoreSyncDeriveKey(passphrase: passphrase);

Future<void> syncWebdavTestConnection(
        {required String baseUrl,
        String? username,
        String? password,
        required String remoteRoot}) =>
    RustLib.instance.api.crateApiCoreSyncWebdavTestConnection(
        baseUrl: baseUrl,
        username: username,
        password: password,
        remoteRoot: remoteRoot);

Future<BigInt> syncWebdavPush(
        {required String appDir,
        required List<int> key,
        required List<int> syncKey,
        required String baseUrl,
        String? username,
        String? password,
        required String remoteRoot}) =>
    RustLib.instance.api.crateApiCoreSyncWebdavPush(
        appDir: appDir,
        key: key,
        syncKey: syncKey,
        baseUrl: baseUrl,
        username: username,
        password: password,
        remoteRoot: remoteRoot);

Future<BigInt> syncWebdavPull(
        {required String appDir,
        required List<int> key,
        required List<int> syncKey,
        required String baseUrl,
        String? username,
        String? password,
        required String remoteRoot}) =>
    RustLib.instance.api.crateApiCoreSyncWebdavPull(
        appDir: appDir,
        key: key,
        syncKey: syncKey,
        baseUrl: baseUrl,
        username: username,
        password: password,
        remoteRoot: remoteRoot);

Future<void> syncWebdavClearRemoteRoot(
        {required String baseUrl,
        String? username,
        String? password,
        required String remoteRoot}) =>
    RustLib.instance.api.crateApiCoreSyncWebdavClearRemoteRoot(
        baseUrl: baseUrl,
        username: username,
        password: password,
        remoteRoot: remoteRoot);

Future<void> syncLocaldirTestConnection(
        {required String localDir, required String remoteRoot}) =>
    RustLib.instance.api.crateApiCoreSyncLocaldirTestConnection(
        localDir: localDir, remoteRoot: remoteRoot);

Future<BigInt> syncLocaldirPush(
        {required String appDir,
        required List<int> key,
        required List<int> syncKey,
        required String localDir,
        required String remoteRoot}) =>
    RustLib.instance.api.crateApiCoreSyncLocaldirPush(
        appDir: appDir,
        key: key,
        syncKey: syncKey,
        localDir: localDir,
        remoteRoot: remoteRoot);

Future<BigInt> syncLocaldirPull(
        {required String appDir,
        required List<int> key,
        required List<int> syncKey,
        required String localDir,
        required String remoteRoot}) =>
    RustLib.instance.api.crateApiCoreSyncLocaldirPull(
        appDir: appDir,
        key: key,
        syncKey: syncKey,
        localDir: localDir,
        remoteRoot: remoteRoot);

Future<void> syncLocaldirClearRemoteRoot(
        {required String localDir, required String remoteRoot}) =>
    RustLib.instance.api.crateApiCoreSyncLocaldirClearRemoteRoot(
        localDir: localDir, remoteRoot: remoteRoot);

Future<BigInt> syncManagedVaultPush(
        {required String appDir,
        required List<int> key,
        required List<int> syncKey,
        required String baseUrl,
        required String vaultId,
        required String firebaseIdToken}) =>
    RustLib.instance.api.crateApiCoreSyncManagedVaultPush(
        appDir: appDir,
        key: key,
        syncKey: syncKey,
        baseUrl: baseUrl,
        vaultId: vaultId,
        firebaseIdToken: firebaseIdToken);

Future<BigInt> syncManagedVaultPull(
        {required String appDir,
        required List<int> key,
        required List<int> syncKey,
        required String baseUrl,
        required String vaultId,
        required String firebaseIdToken}) =>
    RustLib.instance.api.crateApiCoreSyncManagedVaultPull(
        appDir: appDir,
        key: key,
        syncKey: syncKey,
        baseUrl: baseUrl,
        vaultId: vaultId,
        firebaseIdToken: firebaseIdToken);
