// This file is automatically generated, so please do not edit it.
// Generated by `flutter_rust_bridge`@ 2.0.0-dev.38.

// ignore_for_file: invalid_use_of_internal_member, unused_import, unnecessary_import

import '../db.dart';
import '../frb_generated.dart';
import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated.dart';

// These functions are ignored because they are not marked as `pub`: `default_embedding_model_name_for_platform`, `key_from_bytes`, `normalize_embedding_model_name`, `sync_key_from_bytes`

Future<bool> authIsInitialized({required String appDir}) =>
    RustLib.instance.api.crateApiCoreAuthIsInitialized(appDir: appDir);

Future<Uint8List> authInitMasterPassword(
        {required String appDir, required String password}) =>
    RustLib.instance.api
        .crateApiCoreAuthInitMasterPassword(appDir: appDir, password: password);

Future<Uint8List> authUnlockWithPassword(
        {required String appDir, required String password}) =>
    RustLib.instance.api
        .crateApiCoreAuthUnlockWithPassword(appDir: appDir, password: password);

Future<void> authValidateKey(
        {required String appDir, required List<int> key}) =>
    RustLib.instance.api.crateApiCoreAuthValidateKey(appDir: appDir, key: key);

Future<List<Conversation>> dbListConversations(
        {required String appDir, required List<int> key}) =>
    RustLib.instance.api
        .crateApiCoreDbListConversations(appDir: appDir, key: key);

Future<Conversation> dbCreateConversation(
        {required String appDir,
        required List<int> key,
        required String title}) =>
    RustLib.instance.api.crateApiCoreDbCreateConversation(
        appDir: appDir, key: key, title: title);

Future<Conversation> dbGetOrCreateMainStreamConversation(
        {required String appDir, required List<int> key}) =>
    RustLib.instance.api.crateApiCoreDbGetOrCreateMainStreamConversation(
        appDir: appDir, key: key);

Future<List<Message>> dbListMessages(
        {required String appDir,
        required List<int> key,
        required String conversationId}) =>
    RustLib.instance.api.crateApiCoreDbListMessages(
        appDir: appDir, key: key, conversationId: conversationId);

Future<List<Message>> dbListMessagesPage(
        {required String appDir,
        required List<int> key,
        required String conversationId,
        PlatformInt64? beforeCreatedAtMs,
        String? beforeId,
        required int limit}) =>
    RustLib.instance.api.crateApiCoreDbListMessagesPage(
        appDir: appDir,
        key: key,
        conversationId: conversationId,
        beforeCreatedAtMs: beforeCreatedAtMs,
        beforeId: beforeId,
        limit: limit);

Future<Message?> dbGetMessageById(
        {required String appDir,
        required List<int> key,
        required String messageId}) =>
    RustLib.instance.api.crateApiCoreDbGetMessageById(
        appDir: appDir, key: key, messageId: messageId);

Future<Message> dbInsertMessage(
        {required String appDir,
        required List<int> key,
        required String conversationId,
        required String role,
        required String content}) =>
    RustLib.instance.api.crateApiCoreDbInsertMessage(
        appDir: appDir,
        key: key,
        conversationId: conversationId,
        role: role,
        content: content);

Future<Todo> dbUpsertTodo(
        {required String appDir,
        required List<int> key,
        required String id,
        required String title,
        PlatformInt64? dueAtMs,
        required String status,
        String? sourceEntryId,
        PlatformInt64? reviewStage,
        PlatformInt64? nextReviewAtMs,
        PlatformInt64? lastReviewAtMs}) =>
    RustLib.instance.api.crateApiCoreDbUpsertTodo(
        appDir: appDir,
        key: key,
        id: id,
        title: title,
        dueAtMs: dueAtMs,
        status: status,
        sourceEntryId: sourceEntryId,
        reviewStage: reviewStage,
        nextReviewAtMs: nextReviewAtMs,
        lastReviewAtMs: lastReviewAtMs);

Future<List<Todo>> dbListTodos(
        {required String appDir, required List<int> key}) =>
    RustLib.instance.api.crateApiCoreDbListTodos(appDir: appDir, key: key);

Future<List<Todo>> dbListTodosCreatedInRange(
        {required String appDir,
        required List<int> key,
        required PlatformInt64 startAtMsInclusive,
        required PlatformInt64 endAtMsExclusive}) =>
    RustLib.instance.api.crateApiCoreDbListTodosCreatedInRange(
        appDir: appDir,
        key: key,
        startAtMsInclusive: startAtMsInclusive,
        endAtMsExclusive: endAtMsExclusive);

Future<Todo> dbSetTodoStatus(
        {required String appDir,
        required List<int> key,
        required String todoId,
        required String newStatus,
        String? sourceMessageId}) =>
    RustLib.instance.api.crateApiCoreDbSetTodoStatus(
        appDir: appDir,
        key: key,
        todoId: todoId,
        newStatus: newStatus,
        sourceMessageId: sourceMessageId);

Future<BigInt> dbDeleteTodoAndAssociatedMessages(
        {required String appDir,
        required List<int> key,
        required String todoId}) =>
    RustLib.instance.api.crateApiCoreDbDeleteTodoAndAssociatedMessages(
        appDir: appDir, key: key, todoId: todoId);

Future<TodoActivity> dbAppendTodoNote(
        {required String appDir,
        required List<int> key,
        required String todoId,
        required String content,
        String? sourceMessageId}) =>
    RustLib.instance.api.crateApiCoreDbAppendTodoNote(
        appDir: appDir,
        key: key,
        todoId: todoId,
        content: content,
        sourceMessageId: sourceMessageId);

Future<TodoActivity> dbMoveTodoActivity(
        {required String appDir,
        required List<int> key,
        required String activityId,
        required String toTodoId}) =>
    RustLib.instance.api.crateApiCoreDbMoveTodoActivity(
        appDir: appDir, key: key, activityId: activityId, toTodoId: toTodoId);

Future<List<TodoActivity>> dbListTodoActivities(
        {required String appDir,
        required List<int> key,
        required String todoId}) =>
    RustLib.instance.api.crateApiCoreDbListTodoActivities(
        appDir: appDir, key: key, todoId: todoId);

Future<List<TodoActivity>> dbListTodoActivitiesInRange(
        {required String appDir,
        required List<int> key,
        required PlatformInt64 startAtMsInclusive,
        required PlatformInt64 endAtMsExclusive}) =>
    RustLib.instance.api.crateApiCoreDbListTodoActivitiesInRange(
        appDir: appDir,
        key: key,
        startAtMsInclusive: startAtMsInclusive,
        endAtMsExclusive: endAtMsExclusive);

Future<void> dbLinkAttachmentToTodoActivity(
        {required String appDir,
        required List<int> key,
        required String activityId,
        required String attachmentSha256}) =>
    RustLib.instance.api.crateApiCoreDbLinkAttachmentToTodoActivity(
        appDir: appDir,
        key: key,
        activityId: activityId,
        attachmentSha256: attachmentSha256);

Future<List<Attachment>> dbListTodoActivityAttachments(
        {required String appDir,
        required List<int> key,
        required String activityId}) =>
    RustLib.instance.api.crateApiCoreDbListTodoActivityAttachments(
        appDir: appDir, key: key, activityId: activityId);

Future<Event> dbUpsertEvent(
        {required String appDir,
        required List<int> key,
        required String id,
        required String title,
        required PlatformInt64 startAtMs,
        required PlatformInt64 endAtMs,
        required String tz,
        String? sourceEntryId}) =>
    RustLib.instance.api.crateApiCoreDbUpsertEvent(
        appDir: appDir,
        key: key,
        id: id,
        title: title,
        startAtMs: startAtMs,
        endAtMs: endAtMs,
        tz: tz,
        sourceEntryId: sourceEntryId);

Future<List<Event>> dbListEvents(
        {required String appDir, required List<int> key}) =>
    RustLib.instance.api.crateApiCoreDbListEvents(appDir: appDir, key: key);

Future<void> dbEditMessage(
        {required String appDir,
        required List<int> key,
        required String messageId,
        required String content}) =>
    RustLib.instance.api.crateApiCoreDbEditMessage(
        appDir: appDir, key: key, messageId: messageId, content: content);

Future<void> dbSetMessageDeleted(
        {required String appDir,
        required List<int> key,
        required String messageId,
        required bool isDeleted}) =>
    RustLib.instance.api.crateApiCoreDbSetMessageDeleted(
        appDir: appDir, key: key, messageId: messageId, isDeleted: isDeleted);

Future<BigInt> dbPurgeMessageAttachments(
        {required String appDir,
        required List<int> key,
        required String messageId}) =>
    RustLib.instance.api.crateApiCoreDbPurgeMessageAttachments(
        appDir: appDir, key: key, messageId: messageId);

Future<void> dbClearLocalAttachmentCache(
        {required String appDir, required List<int> key}) =>
    RustLib.instance.api
        .crateApiCoreDbClearLocalAttachmentCache(appDir: appDir, key: key);

Future<Attachment> dbInsertAttachment(
        {required String appDir,
        required List<int> key,
        required List<int> bytes,
        required String mimeType}) =>
    RustLib.instance.api.crateApiCoreDbInsertAttachment(
        appDir: appDir, key: key, bytes: bytes, mimeType: mimeType);

Future<void> dbLinkAttachmentToMessage(
        {required String appDir,
        required List<int> key,
        required String messageId,
        required String attachmentSha256}) =>
    RustLib.instance.api.crateApiCoreDbLinkAttachmentToMessage(
        appDir: appDir,
        key: key,
        messageId: messageId,
        attachmentSha256: attachmentSha256);

Future<List<Attachment>> dbListMessageAttachments(
        {required String appDir,
        required List<int> key,
        required String messageId}) =>
    RustLib.instance.api.crateApiCoreDbListMessageAttachments(
        appDir: appDir, key: key, messageId: messageId);

Future<List<Attachment>> dbListRecentAttachments(
        {required String appDir, required List<int> key, required int limit}) =>
    RustLib.instance.api.crateApiCoreDbListRecentAttachments(
        appDir: appDir, key: key, limit: limit);

Future<Uint8List> dbReadAttachmentBytes(
        {required String appDir,
        required List<int> key,
        required String sha256}) =>
    RustLib.instance.api.crateApiCoreDbReadAttachmentBytes(
        appDir: appDir, key: key, sha256: sha256);

Future<void> dbUpsertAttachmentExifMetadata(
        {required String appDir,
        required List<int> key,
        required String attachmentSha256,
        PlatformInt64? capturedAtMs,
        double? latitude,
        double? longitude}) =>
    RustLib.instance.api.crateApiCoreDbUpsertAttachmentExifMetadata(
        appDir: appDir,
        key: key,
        attachmentSha256: attachmentSha256,
        capturedAtMs: capturedAtMs,
        latitude: latitude,
        longitude: longitude);

Future<AttachmentExifMetadata?> dbReadAttachmentExifMetadata(
        {required String appDir,
        required List<int> key,
        required String attachmentSha256}) =>
    RustLib.instance.api.crateApiCoreDbReadAttachmentExifMetadata(
        appDir: appDir, key: key, attachmentSha256: attachmentSha256);

Future<AttachmentVariant> dbUpsertAttachmentVariant(
        {required String appDir,
        required List<int> key,
        required String attachmentSha256,
        required String variant,
        required List<int> bytes,
        required String mimeType}) =>
    RustLib.instance.api.crateApiCoreDbUpsertAttachmentVariant(
        appDir: appDir,
        key: key,
        attachmentSha256: attachmentSha256,
        variant: variant,
        bytes: bytes,
        mimeType: mimeType);

Future<Uint8List> dbReadAttachmentVariantBytes(
        {required String appDir,
        required List<int> key,
        required String attachmentSha256,
        required String variant}) =>
    RustLib.instance.api.crateApiCoreDbReadAttachmentVariantBytes(
        appDir: appDir,
        key: key,
        attachmentSha256: attachmentSha256,
        variant: variant);

Future<void> dbEnqueueCloudMediaBackup(
        {required String appDir,
        required List<int> key,
        required String attachmentSha256,
        required String desiredVariant,
        required PlatformInt64 nowMs}) =>
    RustLib.instance.api.crateApiCoreDbEnqueueCloudMediaBackup(
        appDir: appDir,
        key: key,
        attachmentSha256: attachmentSha256,
        desiredVariant: desiredVariant,
        nowMs: nowMs);

Future<BigInt> dbBackfillCloudMediaBackupImages(
        {required String appDir,
        required List<int> key,
        required String desiredVariant,
        required PlatformInt64 nowMs}) =>
    RustLib.instance.api.crateApiCoreDbBackfillCloudMediaBackupImages(
        appDir: appDir, key: key, desiredVariant: desiredVariant, nowMs: nowMs);

Future<List<CloudMediaBackup>> dbListDueCloudMediaBackups(
        {required String appDir,
        required List<int> key,
        required PlatformInt64 nowMs,
        required int limit}) =>
    RustLib.instance.api.crateApiCoreDbListDueCloudMediaBackups(
        appDir: appDir, key: key, nowMs: nowMs, limit: limit);

Future<void> dbMarkCloudMediaBackupFailed(
        {required String appDir,
        required List<int> key,
        required String attachmentSha256,
        required PlatformInt64 attempts,
        required PlatformInt64 nextRetryAtMs,
        required String lastError,
        required PlatformInt64 nowMs}) =>
    RustLib.instance.api.crateApiCoreDbMarkCloudMediaBackupFailed(
        appDir: appDir,
        key: key,
        attachmentSha256: attachmentSha256,
        attempts: attempts,
        nextRetryAtMs: nextRetryAtMs,
        lastError: lastError,
        nowMs: nowMs);

Future<void> dbMarkCloudMediaBackupUploaded(
        {required String appDir,
        required List<int> key,
        required String attachmentSha256,
        required PlatformInt64 nowMs}) =>
    RustLib.instance.api.crateApiCoreDbMarkCloudMediaBackupUploaded(
        appDir: appDir,
        key: key,
        attachmentSha256: attachmentSha256,
        nowMs: nowMs);

Future<CloudMediaBackupSummary> dbCloudMediaBackupSummary(
        {required String appDir, required List<int> key}) =>
    RustLib.instance.api
        .crateApiCoreDbCloudMediaBackupSummary(appDir: appDir, key: key);

Future<void> dbResetVaultDataPreservingLlmProfiles(
        {required String appDir, required List<int> key}) =>
    RustLib.instance.api.crateApiCoreDbResetVaultDataPreservingLlmProfiles(
        appDir: appDir, key: key);

Future<String> dbGetOrCreateDeviceId({required String appDir}) =>
    RustLib.instance.api.crateApiCoreDbGetOrCreateDeviceId(appDir: appDir);

Future<LlmProfile> dbCreateLlmProfile(
        {required String appDir,
        required List<int> key,
        required String name,
        required String providerType,
        String? baseUrl,
        String? apiKey,
        required String modelName,
        required bool setActive}) =>
    RustLib.instance.api.crateApiCoreDbCreateLlmProfile(
        appDir: appDir,
        key: key,
        name: name,
        providerType: providerType,
        baseUrl: baseUrl,
        apiKey: apiKey,
        modelName: modelName,
        setActive: setActive);

Future<List<LlmProfile>> dbListLlmProfiles(
        {required String appDir, required List<int> key}) =>
    RustLib.instance.api
        .crateApiCoreDbListLlmProfiles(appDir: appDir, key: key);

Future<void> dbSetActiveLlmProfile(
        {required String appDir,
        required List<int> key,
        required String profileId}) =>
    RustLib.instance.api.crateApiCoreDbSetActiveLlmProfile(
        appDir: appDir, key: key, profileId: profileId);

Future<void> dbDeleteLlmProfile(
        {required String appDir,
        required List<int> key,
        required String profileId}) =>
    RustLib.instance.api.crateApiCoreDbDeleteLlmProfile(
        appDir: appDir, key: key, profileId: profileId);

Future<EmbeddingProfile> dbCreateEmbeddingProfile(
        {required String appDir,
        required List<int> key,
        required String name,
        required String providerType,
        String? baseUrl,
        String? apiKey,
        required String modelName,
        required bool setActive}) =>
    RustLib.instance.api.crateApiCoreDbCreateEmbeddingProfile(
        appDir: appDir,
        key: key,
        name: name,
        providerType: providerType,
        baseUrl: baseUrl,
        apiKey: apiKey,
        modelName: modelName,
        setActive: setActive);

Future<List<EmbeddingProfile>> dbListEmbeddingProfiles(
        {required String appDir, required List<int> key}) =>
    RustLib.instance.api
        .crateApiCoreDbListEmbeddingProfiles(appDir: appDir, key: key);

Future<void> dbSetActiveEmbeddingProfile(
        {required String appDir,
        required List<int> key,
        required String profileId}) =>
    RustLib.instance.api.crateApiCoreDbSetActiveEmbeddingProfile(
        appDir: appDir, key: key, profileId: profileId);

Future<void> dbDeleteEmbeddingProfile(
        {required String appDir,
        required List<int> key,
        required String profileId}) =>
    RustLib.instance.api.crateApiCoreDbDeleteEmbeddingProfile(
        appDir: appDir, key: key, profileId: profileId);

Future<int> dbProcessPendingMessageEmbeddings(
        {required String appDir, required List<int> key, required int limit}) =>
    RustLib.instance.api.crateApiCoreDbProcessPendingMessageEmbeddings(
        appDir: appDir, key: key, limit: limit);

Future<int> dbProcessPendingTodoThreadEmbeddings(
        {required String appDir,
        required List<int> key,
        required int todoLimit,
        required int activityLimit}) =>
    RustLib.instance.api.crateApiCoreDbProcessPendingTodoThreadEmbeddings(
        appDir: appDir,
        key: key,
        todoLimit: todoLimit,
        activityLimit: activityLimit);

Future<int> dbProcessPendingTodoThreadEmbeddingsCloudGateway(
        {required String appDir,
        required List<int> key,
        required int todoLimit,
        required int activityLimit,
        required String gatewayBaseUrl,
        required String firebaseIdToken,
        required String modelName}) =>
    RustLib.instance.api
        .crateApiCoreDbProcessPendingTodoThreadEmbeddingsCloudGateway(
            appDir: appDir,
            key: key,
            todoLimit: todoLimit,
            activityLimit: activityLimit,
            gatewayBaseUrl: gatewayBaseUrl,
            firebaseIdToken: firebaseIdToken,
            modelName: modelName);

Future<int> dbProcessPendingTodoThreadEmbeddingsBrok(
        {required String appDir,
        required List<int> key,
        required int todoLimit,
        required int activityLimit}) =>
    RustLib.instance.api.crateApiCoreDbProcessPendingTodoThreadEmbeddingsBrok(
        appDir: appDir,
        key: key,
        todoLimit: todoLimit,
        activityLimit: activityLimit);

Future<List<SimilarMessage>> dbSearchSimilarMessages(
        {required String appDir,
        required List<int> key,
        required String query,
        required int topK}) =>
    RustLib.instance.api.crateApiCoreDbSearchSimilarMessages(
        appDir: appDir, key: key, query: query, topK: topK);

Future<List<SimilarMessage>> dbSearchSimilarMessagesCloudGateway(
        {required String appDir,
        required List<int> key,
        required String query,
        required int topK,
        required String gatewayBaseUrl,
        required String firebaseIdToken,
        required String modelName}) =>
    RustLib.instance.api.crateApiCoreDbSearchSimilarMessagesCloudGateway(
        appDir: appDir,
        key: key,
        query: query,
        topK: topK,
        gatewayBaseUrl: gatewayBaseUrl,
        firebaseIdToken: firebaseIdToken,
        modelName: modelName);

Future<List<SimilarMessage>> dbSearchSimilarMessagesBrok(
        {required String appDir,
        required List<int> key,
        required String query,
        required int topK}) =>
    RustLib.instance.api.crateApiCoreDbSearchSimilarMessagesBrok(
        appDir: appDir, key: key, query: query, topK: topK);

Future<List<SimilarTodoThread>> dbSearchSimilarTodoThreads(
        {required String appDir,
        required List<int> key,
        required String query,
        required int topK}) =>
    RustLib.instance.api.crateApiCoreDbSearchSimilarTodoThreads(
        appDir: appDir, key: key, query: query, topK: topK);

Future<List<SimilarTodoThread>> dbSearchSimilarTodoThreadsCloudGateway(
        {required String appDir,
        required List<int> key,
        required String query,
        required int topK,
        required String gatewayBaseUrl,
        required String firebaseIdToken,
        required String modelName}) =>
    RustLib.instance.api.crateApiCoreDbSearchSimilarTodoThreadsCloudGateway(
        appDir: appDir,
        key: key,
        query: query,
        topK: topK,
        gatewayBaseUrl: gatewayBaseUrl,
        firebaseIdToken: firebaseIdToken,
        modelName: modelName);

Future<List<SimilarTodoThread>> dbSearchSimilarTodoThreadsBrok(
        {required String appDir,
        required List<int> key,
        required String query,
        required int topK}) =>
    RustLib.instance.api.crateApiCoreDbSearchSimilarTodoThreadsBrok(
        appDir: appDir, key: key, query: query, topK: topK);

Future<int> dbRebuildMessageEmbeddings(
        {required String appDir,
        required List<int> key,
        required int batchLimit}) =>
    RustLib.instance.api.crateApiCoreDbRebuildMessageEmbeddings(
        appDir: appDir, key: key, batchLimit: batchLimit);

Future<List<String>> dbListEmbeddingModelNames(
        {required String appDir, required List<int> key}) =>
    RustLib.instance.api
        .crateApiCoreDbListEmbeddingModelNames(appDir: appDir, key: key);

Future<String> dbGetActiveEmbeddingModelName(
        {required String appDir, required List<int> key}) =>
    RustLib.instance.api
        .crateApiCoreDbGetActiveEmbeddingModelName(appDir: appDir, key: key);

Future<bool> dbSetActiveEmbeddingModelName(
        {required String appDir,
        required List<int> key,
        required String modelName}) =>
    RustLib.instance.api.crateApiCoreDbSetActiveEmbeddingModelName(
        appDir: appDir, key: key, modelName: modelName);

Future<void> dbRecordLlmUsageDaily(
        {required String appDir,
        required List<int> key,
        required String day,
        required String profileId,
        required String purpose,
        PlatformInt64? inputTokens,
        PlatformInt64? outputTokens,
        PlatformInt64? totalTokens}) =>
    RustLib.instance.api.crateApiCoreDbRecordLlmUsageDaily(
        appDir: appDir,
        key: key,
        day: day,
        profileId: profileId,
        purpose: purpose,
        inputTokens: inputTokens,
        outputTokens: outputTokens,
        totalTokens: totalTokens);

Future<List<LlmUsageAggregate>> dbSumLlmUsageDailyByPurpose(
        {required String appDir,
        required List<int> key,
        required String profileId,
        required String startDay,
        required String endDay}) =>
    RustLib.instance.api.crateApiCoreDbSumLlmUsageDailyByPurpose(
        appDir: appDir,
        key: key,
        profileId: profileId,
        startDay: startDay,
        endDay: endDay);

Stream<String> ragAskAiStream(
        {required String appDir,
        required List<int> key,
        required String conversationId,
        required String question,
        required int topK,
        required bool thisThreadOnly,
        required String localDay}) =>
    RustLib.instance.api.crateApiCoreRagAskAiStream(
        appDir: appDir,
        key: key,
        conversationId: conversationId,
        question: question,
        topK: topK,
        thisThreadOnly: thisThreadOnly,
        localDay: localDay);

Stream<String> ragAskAiStreamTimeWindow(
        {required String appDir,
        required List<int> key,
        required String conversationId,
        required String question,
        required int topK,
        required bool thisThreadOnly,
        required PlatformInt64 timeStartMs,
        required PlatformInt64 timeEndMs,
        required String localDay}) =>
    RustLib.instance.api.crateApiCoreRagAskAiStreamTimeWindow(
        appDir: appDir,
        key: key,
        conversationId: conversationId,
        question: question,
        topK: topK,
        thisThreadOnly: thisThreadOnly,
        timeStartMs: timeStartMs,
        timeEndMs: timeEndMs,
        localDay: localDay);

Stream<String> ragAskAiStreamWithBrokEmbeddings(
        {required String appDir,
        required List<int> key,
        required String conversationId,
        required String question,
        required int topK,
        required bool thisThreadOnly,
        required String localDay}) =>
    RustLib.instance.api.crateApiCoreRagAskAiStreamWithBrokEmbeddings(
        appDir: appDir,
        key: key,
        conversationId: conversationId,
        question: question,
        topK: topK,
        thisThreadOnly: thisThreadOnly,
        localDay: localDay);

Stream<String> ragAskAiStreamWithBrokEmbeddingsTimeWindow(
        {required String appDir,
        required List<int> key,
        required String conversationId,
        required String question,
        required int topK,
        required bool thisThreadOnly,
        required PlatformInt64 timeStartMs,
        required PlatformInt64 timeEndMs,
        required String localDay}) =>
    RustLib.instance.api.crateApiCoreRagAskAiStreamWithBrokEmbeddingsTimeWindow(
        appDir: appDir,
        key: key,
        conversationId: conversationId,
        question: question,
        topK: topK,
        thisThreadOnly: thisThreadOnly,
        timeStartMs: timeStartMs,
        timeEndMs: timeEndMs,
        localDay: localDay);

Stream<String> ragAskAiStreamCloudGateway(
        {required String appDir,
        required List<int> key,
        required String conversationId,
        required String question,
        required int topK,
        required bool thisThreadOnly,
        required String gatewayBaseUrl,
        required String firebaseIdToken,
        required String modelName}) =>
    RustLib.instance.api.crateApiCoreRagAskAiStreamCloudGateway(
        appDir: appDir,
        key: key,
        conversationId: conversationId,
        question: question,
        topK: topK,
        thisThreadOnly: thisThreadOnly,
        gatewayBaseUrl: gatewayBaseUrl,
        firebaseIdToken: firebaseIdToken,
        modelName: modelName);

Stream<String> ragAskAiStreamCloudGatewayTimeWindow(
        {required String appDir,
        required List<int> key,
        required String conversationId,
        required String question,
        required int topK,
        required bool thisThreadOnly,
        required PlatformInt64 timeStartMs,
        required PlatformInt64 timeEndMs,
        required String gatewayBaseUrl,
        required String firebaseIdToken,
        required String modelName}) =>
    RustLib.instance.api.crateApiCoreRagAskAiStreamCloudGatewayTimeWindow(
        appDir: appDir,
        key: key,
        conversationId: conversationId,
        question: question,
        topK: topK,
        thisThreadOnly: thisThreadOnly,
        timeStartMs: timeStartMs,
        timeEndMs: timeEndMs,
        gatewayBaseUrl: gatewayBaseUrl,
        firebaseIdToken: firebaseIdToken,
        modelName: modelName);

Stream<String> ragAskAiStreamCloudGatewayWithEmbeddings(
        {required String appDir,
        required List<int> key,
        required String conversationId,
        required String question,
        required int topK,
        required bool thisThreadOnly,
        required String gatewayBaseUrl,
        required String firebaseIdToken,
        required String modelName,
        required String embeddingsModelName}) =>
    RustLib.instance.api.crateApiCoreRagAskAiStreamCloudGatewayWithEmbeddings(
        appDir: appDir,
        key: key,
        conversationId: conversationId,
        question: question,
        topK: topK,
        thisThreadOnly: thisThreadOnly,
        gatewayBaseUrl: gatewayBaseUrl,
        firebaseIdToken: firebaseIdToken,
        modelName: modelName,
        embeddingsModelName: embeddingsModelName);

Stream<String> ragAskAiStreamCloudGatewayWithEmbeddingsTimeWindow(
        {required String appDir,
        required List<int> key,
        required String conversationId,
        required String question,
        required int topK,
        required bool thisThreadOnly,
        required PlatformInt64 timeStartMs,
        required PlatformInt64 timeEndMs,
        required String gatewayBaseUrl,
        required String firebaseIdToken,
        required String modelName,
        required String embeddingsModelName}) =>
    RustLib.instance.api
        .crateApiCoreRagAskAiStreamCloudGatewayWithEmbeddingsTimeWindow(
            appDir: appDir,
            key: key,
            conversationId: conversationId,
            question: question,
            topK: topK,
            thisThreadOnly: thisThreadOnly,
            timeStartMs: timeStartMs,
            timeEndMs: timeEndMs,
            gatewayBaseUrl: gatewayBaseUrl,
            firebaseIdToken: firebaseIdToken,
            modelName: modelName,
            embeddingsModelName: embeddingsModelName);

Future<Uint8List> syncDeriveKey({required String passphrase}) =>
    RustLib.instance.api.crateApiCoreSyncDeriveKey(passphrase: passphrase);

Future<void> syncWebdavTestConnection(
        {required String baseUrl,
        String? username,
        String? password,
        required String remoteRoot}) =>
    RustLib.instance.api.crateApiCoreSyncWebdavTestConnection(
        baseUrl: baseUrl,
        username: username,
        password: password,
        remoteRoot: remoteRoot);

Future<BigInt> syncWebdavPush(
        {required String appDir,
        required List<int> key,
        required List<int> syncKey,
        required String baseUrl,
        String? username,
        String? password,
        required String remoteRoot}) =>
    RustLib.instance.api.crateApiCoreSyncWebdavPush(
        appDir: appDir,
        key: key,
        syncKey: syncKey,
        baseUrl: baseUrl,
        username: username,
        password: password,
        remoteRoot: remoteRoot);

Future<BigInt> syncWebdavPushOpsOnly(
        {required String appDir,
        required List<int> key,
        required List<int> syncKey,
        required String baseUrl,
        String? username,
        String? password,
        required String remoteRoot}) =>
    RustLib.instance.api.crateApiCoreSyncWebdavPushOpsOnly(
        appDir: appDir,
        key: key,
        syncKey: syncKey,
        baseUrl: baseUrl,
        username: username,
        password: password,
        remoteRoot: remoteRoot);

Future<BigInt> syncWebdavPull(
        {required String appDir,
        required List<int> key,
        required List<int> syncKey,
        required String baseUrl,
        String? username,
        String? password,
        required String remoteRoot}) =>
    RustLib.instance.api.crateApiCoreSyncWebdavPull(
        appDir: appDir,
        key: key,
        syncKey: syncKey,
        baseUrl: baseUrl,
        username: username,
        password: password,
        remoteRoot: remoteRoot);

Future<void> syncWebdavDownloadAttachmentBytes(
        {required String appDir,
        required List<int> key,
        required List<int> syncKey,
        required String baseUrl,
        String? username,
        String? password,
        required String remoteRoot,
        required String sha256}) =>
    RustLib.instance.api.crateApiCoreSyncWebdavDownloadAttachmentBytes(
        appDir: appDir,
        key: key,
        syncKey: syncKey,
        baseUrl: baseUrl,
        username: username,
        password: password,
        remoteRoot: remoteRoot,
        sha256: sha256);

Future<bool> syncWebdavUploadAttachmentBytes(
        {required String appDir,
        required List<int> key,
        required List<int> syncKey,
        required String baseUrl,
        String? username,
        String? password,
        required String remoteRoot,
        required String sha256}) =>
    RustLib.instance.api.crateApiCoreSyncWebdavUploadAttachmentBytes(
        appDir: appDir,
        key: key,
        syncKey: syncKey,
        baseUrl: baseUrl,
        username: username,
        password: password,
        remoteRoot: remoteRoot,
        sha256: sha256);

Future<void> syncWebdavClearRemoteRoot(
        {required String baseUrl,
        String? username,
        String? password,
        required String remoteRoot}) =>
    RustLib.instance.api.crateApiCoreSyncWebdavClearRemoteRoot(
        baseUrl: baseUrl,
        username: username,
        password: password,
        remoteRoot: remoteRoot);

Future<void> syncLocaldirTestConnection(
        {required String localDir, required String remoteRoot}) =>
    RustLib.instance.api.crateApiCoreSyncLocaldirTestConnection(
        localDir: localDir, remoteRoot: remoteRoot);

Future<BigInt> syncLocaldirPush(
        {required String appDir,
        required List<int> key,
        required List<int> syncKey,
        required String localDir,
        required String remoteRoot}) =>
    RustLib.instance.api.crateApiCoreSyncLocaldirPush(
        appDir: appDir,
        key: key,
        syncKey: syncKey,
        localDir: localDir,
        remoteRoot: remoteRoot);

Future<BigInt> syncLocaldirPushOpsOnly(
        {required String appDir,
        required List<int> key,
        required List<int> syncKey,
        required String localDir,
        required String remoteRoot}) =>
    RustLib.instance.api.crateApiCoreSyncLocaldirPushOpsOnly(
        appDir: appDir,
        key: key,
        syncKey: syncKey,
        localDir: localDir,
        remoteRoot: remoteRoot);

Future<BigInt> syncLocaldirPull(
        {required String appDir,
        required List<int> key,
        required List<int> syncKey,
        required String localDir,
        required String remoteRoot}) =>
    RustLib.instance.api.crateApiCoreSyncLocaldirPull(
        appDir: appDir,
        key: key,
        syncKey: syncKey,
        localDir: localDir,
        remoteRoot: remoteRoot);

Future<void> syncLocaldirDownloadAttachmentBytes(
        {required String appDir,
        required List<int> key,
        required List<int> syncKey,
        required String localDir,
        required String remoteRoot,
        required String sha256}) =>
    RustLib.instance.api.crateApiCoreSyncLocaldirDownloadAttachmentBytes(
        appDir: appDir,
        key: key,
        syncKey: syncKey,
        localDir: localDir,
        remoteRoot: remoteRoot,
        sha256: sha256);

Future<bool> syncLocaldirUploadAttachmentBytes(
        {required String appDir,
        required List<int> key,
        required List<int> syncKey,
        required String localDir,
        required String remoteRoot,
        required String sha256}) =>
    RustLib.instance.api.crateApiCoreSyncLocaldirUploadAttachmentBytes(
        appDir: appDir,
        key: key,
        syncKey: syncKey,
        localDir: localDir,
        remoteRoot: remoteRoot,
        sha256: sha256);

Future<void> syncLocaldirClearRemoteRoot(
        {required String localDir, required String remoteRoot}) =>
    RustLib.instance.api.crateApiCoreSyncLocaldirClearRemoteRoot(
        localDir: localDir, remoteRoot: remoteRoot);

Future<BigInt> syncManagedVaultPush(
        {required String appDir,
        required List<int> key,
        required List<int> syncKey,
        required String baseUrl,
        required String vaultId,
        required String firebaseIdToken}) =>
    RustLib.instance.api.crateApiCoreSyncManagedVaultPush(
        appDir: appDir,
        key: key,
        syncKey: syncKey,
        baseUrl: baseUrl,
        vaultId: vaultId,
        firebaseIdToken: firebaseIdToken);

Future<BigInt> syncManagedVaultPushOpsOnly(
        {required String appDir,
        required List<int> key,
        required List<int> syncKey,
        required String baseUrl,
        required String vaultId,
        required String firebaseIdToken}) =>
    RustLib.instance.api.crateApiCoreSyncManagedVaultPushOpsOnly(
        appDir: appDir,
        key: key,
        syncKey: syncKey,
        baseUrl: baseUrl,
        vaultId: vaultId,
        firebaseIdToken: firebaseIdToken);

Future<BigInt> syncManagedVaultPull(
        {required String appDir,
        required List<int> key,
        required List<int> syncKey,
        required String baseUrl,
        required String vaultId,
        required String firebaseIdToken}) =>
    RustLib.instance.api.crateApiCoreSyncManagedVaultPull(
        appDir: appDir,
        key: key,
        syncKey: syncKey,
        baseUrl: baseUrl,
        vaultId: vaultId,
        firebaseIdToken: firebaseIdToken);

Future<bool> syncManagedVaultUploadAttachmentBytes(
        {required String appDir,
        required List<int> key,
        required List<int> syncKey,
        required String baseUrl,
        required String vaultId,
        required String firebaseIdToken,
        required String sha256}) =>
    RustLib.instance.api.crateApiCoreSyncManagedVaultUploadAttachmentBytes(
        appDir: appDir,
        key: key,
        syncKey: syncKey,
        baseUrl: baseUrl,
        vaultId: vaultId,
        firebaseIdToken: firebaseIdToken,
        sha256: sha256);

Future<void> syncManagedVaultDownloadAttachmentBytes(
        {required String appDir,
        required List<int> key,
        required List<int> syncKey,
        required String baseUrl,
        required String vaultId,
        required String firebaseIdToken,
        required String sha256}) =>
    RustLib.instance.api.crateApiCoreSyncManagedVaultDownloadAttachmentBytes(
        appDir: appDir,
        key: key,
        syncKey: syncKey,
        baseUrl: baseUrl,
        vaultId: vaultId,
        firebaseIdToken: firebaseIdToken,
        sha256: sha256);

Future<void> syncManagedVaultClearDevice(
        {required String baseUrl,
        required String vaultId,
        required String firebaseIdToken,
        required String deviceId}) =>
    RustLib.instance.api.crateApiCoreSyncManagedVaultClearDevice(
        baseUrl: baseUrl,
        vaultId: vaultId,
        firebaseIdToken: firebaseIdToken,
        deviceId: deviceId);

Future<void> syncManagedVaultClearVault(
        {required String baseUrl,
        required String vaultId,
        required String firebaseIdToken}) =>
    RustLib.instance.api.crateApiCoreSyncManagedVaultClearVault(
        baseUrl: baseUrl, vaultId: vaultId, firebaseIdToken: firebaseIdToken);
